"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QdrantClient = exports.QdrantStore = void 0;
const js_client_rest_1 = require("@qdrant/js-client-rest");
Object.defineProperty(exports, "QdrantClient", { enumerable: true, get: function () { return js_client_rest_1.QdrantClient; } });
function generateUUID() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
        const r = (Math.random() * 16) | 0;
        const v = c === "x" ? r : (r & 0x3) | 0x8;
        return v.toString(16);
    });
}
class QdrantStore {
    constructor(embeddings, collectionName = "alith", vectorSize = 384, params) {
        this.embeddings = embeddings;
        this.client = new js_client_rest_1.QdrantClient(params);
        this.collectionName = collectionName;
        this.vectorSize = vectorSize;
        this.ensureCollectionExists().then(() => { });
    }
    async ensureCollectionExists() {
        try {
            const collections = await this.client.getCollections();
            const exists = collections.collections.some((c) => c.name === this.collectionName);
            if (!exists) {
                await this.client.createCollection(this.collectionName, {
                    vectors: {
                        size: this.vectorSize,
                        distance: "Cosine",
                    },
                });
            }
        }
        catch (error) { }
    }
    async search(query, limit = 3, scoreThreshold = 0.4) {
        await this.ensureCollectionExists();
        const queryVectors = await this.embedTexts([query]);
        const searchResult = await this.client.search(this.collectionName, {
            vector: queryVectors[0],
            limit,
            score_threshold: scoreThreshold,
        });
        return searchResult.map((point) => point.payload?.text);
    }
    async save(value) {
        await this.ensureCollectionExists();
        const vectors = await this.embedTexts([value]);
        await this.client.upsert(this.collectionName, {
            points: [
                {
                    id: generateUUID(),
                    vector: vectors[0],
                    payload: { text: value },
                },
            ],
        });
    }
    async reset() {
        const collections = await this.client.getCollections();
        const exists = collections.collections.some((c) => c.name === this.collectionName);
        if (exists) {
            await this.client.deleteCollection(this.collectionName);
        }
        await this.client.createCollection(this.collectionName, {
            vectors: {
                size: this.vectorSize,
                distance: "Cosine",
            },
        });
    }
    async saveDocs(values) {
        await this.ensureCollectionExists();
        const vectors = await this.embedTexts(values);
        const points = values.map((value, index) => ({
            id: generateUUID(),
            vector: vectors[index],
            payload: { text: value },
        }));
        await this.client.upsert(this.collectionName, {
            points,
        });
    }
    async embedTexts(text) {
        return this.embeddings.embedTexts(text);
    }
}
exports.QdrantStore = QdrantStore;
